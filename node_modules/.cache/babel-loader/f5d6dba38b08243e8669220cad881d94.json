{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $parseInt = GetIntrinsic('%parseInt%');\n\nvar inspect = require('object-inspect');\n\nvar regexTester = require('../helpers/regexTester');\n\nvar callBound = require('../helpers/callBound');\n\nvar every = require('../helpers/every');\n\nvar isDigit = regexTester(/^[0-9]$/);\nvar $charAt = callBound('String.prototype.charAt');\nvar $strSlice = callBound('String.prototype.slice');\n\nvar IsArray = require('./IsArray');\n\nvar IsInteger = require('./IsInteger');\n\nvar Type = require('./Type');\n\nvar canDistinguishSparseFromUndefined = 0 in [undefined]; // IE 6 - 8 have a bug where this returns false\n\nvar isStringOrHole = function (capture, index, arr) {\n  return Type(capture) === 'String' || (canDistinguishSparseFromUndefined ? !(index in arr) : Type(capture) === 'Undefined');\n}; // https://www.ecma-international.org/ecma-262/6.0/#sec-getsubstitution\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\n\n\nmodule.exports = function GetSubstitution(matched, str, position, captures, replacement) {\n  if (Type(matched) !== 'String') {\n    throw new $TypeError('Assertion failed: `matched` must be a String');\n  }\n\n  var matchLength = matched.length;\n\n  if (Type(str) !== 'String') {\n    throw new $TypeError('Assertion failed: `str` must be a String');\n  }\n\n  var stringLength = str.length;\n\n  if (!IsInteger(position) || position < 0 || position > stringLength) {\n    throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));\n  }\n\n  if (!IsArray(captures) || !every(captures, isStringOrHole)) {\n    throw new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));\n  }\n\n  if (Type(replacement) !== 'String') {\n    throw new $TypeError('Assertion failed: `replacement` must be a String');\n  }\n\n  var tailPos = position + matchLength;\n  var m = captures.length;\n  var result = '';\n\n  for (var i = 0; i < replacement.length; i += 1) {\n    // if this is a $, and it's not the end of the replacement\n    var current = $charAt(replacement, i);\n    var isLast = i + 1 >= replacement.length;\n    var nextIsLast = i + 2 >= replacement.length;\n\n    if (current === '$' && !isLast) {\n      var next = $charAt(replacement, i + 1);\n\n      if (next === '$') {\n        result += '$';\n        i += 1;\n      } else if (next === '&') {\n        result += matched;\n        i += 1;\n      } else if (next === '`') {\n        result += position === 0 ? '' : $strSlice(str, 0, position - 1);\n        i += 1;\n      } else if (next === \"'\") {\n        result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);\n        i += 1;\n      } else {\n        var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);\n\n        if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {\n          // $1 through $9, and not followed by a digit\n          var n = $parseInt(next, 10); // if (n > m, impl-defined)\n\n          result += n <= m && Type(captures[n - 1]) === 'Undefined' ? '' : captures[n - 1];\n          i += 1;\n        } else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {\n          // $00 through $99\n          var nn = next + nextNext;\n          var nnI = $parseInt(nn, 10) - 1; // if nn === '00' or nn > m, impl-defined\n\n          result += nn <= m && Type(captures[nnI]) === 'Undefined' ? '' : captures[nnI];\n          i += 2;\n        } else {\n          result += '$';\n        }\n      }\n    } else {\n      // the final $, or else not a $\n      result += $charAt(replacement, i);\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/atude/projects/kanbie/node_modules/es-abstract/2015/GetSubstitution.js"],"names":["GetIntrinsic","require","$TypeError","$parseInt","inspect","regexTester","callBound","every","isDigit","$charAt","$strSlice","IsArray","IsInteger","Type","canDistinguishSparseFromUndefined","undefined","isStringOrHole","capture","index","arr","module","exports","GetSubstitution","matched","str","position","captures","replacement","matchLength","length","stringLength","tailPos","m","result","i","current","isLast","nextIsLast","next","nextNext","n","nn","nnI"],"mappings":"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","sourcesContent":["\n'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $parseInt = GetIntrinsic('%parseInt%');\n\nvar inspect = require('object-inspect');\n\nvar regexTester = require('../helpers/regexTester');\nvar callBound = require('../helpers/callBound');\nvar every = require('../helpers/every');\n\nvar isDigit = regexTester(/^[0-9]$/);\n\nvar $charAt = callBound('String.prototype.charAt');\nvar $strSlice = callBound('String.prototype.slice');\n\nvar IsArray = require('./IsArray');\nvar IsInteger = require('./IsInteger');\nvar Type = require('./Type');\n\nvar canDistinguishSparseFromUndefined = 0 in [undefined]; // IE 6 - 8 have a bug where this returns false\n\nvar isStringOrHole = function (capture, index, arr) {\n\treturn Type(capture) === 'String' || (canDistinguishSparseFromUndefined ? !(index in arr) : Type(capture) === 'Undefined');\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-getsubstitution\n\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\nmodule.exports = function GetSubstitution(matched, str, position, captures, replacement) {\n\tif (Type(matched) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `matched` must be a String');\n\t}\n\tvar matchLength = matched.length;\n\n\tif (Type(str) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `str` must be a String');\n\t}\n\tvar stringLength = str.length;\n\n\tif (!IsInteger(position) || position < 0 || position > stringLength) {\n\t\tthrow new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));\n\t}\n\n\tif (!IsArray(captures) || !every(captures, isStringOrHole)) {\n\t\tthrow new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));\n\t}\n\n\tif (Type(replacement) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `replacement` must be a String');\n\t}\n\n\tvar tailPos = position + matchLength;\n\tvar m = captures.length;\n\n\tvar result = '';\n\tfor (var i = 0; i < replacement.length; i += 1) {\n\t\t// if this is a $, and it's not the end of the replacement\n\t\tvar current = $charAt(replacement, i);\n\t\tvar isLast = (i + 1) >= replacement.length;\n\t\tvar nextIsLast = (i + 2) >= replacement.length;\n\t\tif (current === '$' && !isLast) {\n\t\t\tvar next = $charAt(replacement, i + 1);\n\t\t\tif (next === '$') {\n\t\t\t\tresult += '$';\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '&') {\n\t\t\t\tresult += matched;\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '`') {\n\t\t\t\tresult += position === 0 ? '' : $strSlice(str, 0, position - 1);\n\t\t\t\ti += 1;\n\t\t\t} else if (next === \"'\") {\n\t\t\t\tresult += tailPos >= stringLength ? '' : $strSlice(str, tailPos);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar nextNext = nextIsLast ? null : $charAt(replacement, i + 2);\n\t\t\t\tif (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {\n\t\t\t\t\t// $1 through $9, and not followed by a digit\n\t\t\t\t\tvar n = $parseInt(next, 10);\n\t\t\t\t\t// if (n > m, impl-defined)\n\t\t\t\t\tresult += (n <= m && Type(captures[n - 1]) === 'Undefined') ? '' : captures[n - 1];\n\t\t\t\t\ti += 1;\n\t\t\t\t} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {\n\t\t\t\t\t// $00 through $99\n\t\t\t\t\tvar nn = next + nextNext;\n\t\t\t\t\tvar nnI = $parseInt(nn, 10) - 1;\n\t\t\t\t\t// if nn === '00' or nn > m, impl-defined\n\t\t\t\t\tresult += (nn <= m && Type(captures[nnI]) === 'Undefined') ? '' : captures[nnI];\n\t\t\t\t\ti += 2;\n\t\t\t\t} else {\n\t\t\t\t\tresult += '$';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// the final $, or else not a $\n\t\t\tresult += $charAt(replacement, i);\n\t\t}\n\t}\n\treturn result;\n};\n"]},"metadata":{},"sourceType":"script"}