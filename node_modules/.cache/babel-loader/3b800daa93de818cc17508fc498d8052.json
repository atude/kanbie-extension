{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $isNaN = require('../helpers/isNaN');\n\nvar $isFinite = require('../helpers/isFinite');\n\nvar isPrefixOf = require('../helpers/isPrefixOf');\n\nvar ToNumber = require('./ToNumber');\n\nvar ToPrimitive = require('./ToPrimitive');\n\nvar Type = require('./Type'); // https://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5\n// eslint-disable-next-line max-statements\n\n\nmodule.exports = function AbstractRelationalComparison(x, y, LeftFirst) {\n  if (Type(LeftFirst) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n  }\n\n  var px;\n  var py;\n\n  if (LeftFirst) {\n    px = ToPrimitive(x, $Number);\n    py = ToPrimitive(y, $Number);\n  } else {\n    py = ToPrimitive(y, $Number);\n    px = ToPrimitive(x, $Number);\n  }\n\n  var bothStrings = Type(px) === 'String' && Type(py) === 'String';\n\n  if (!bothStrings) {\n    var nx = ToNumber(px);\n    var ny = ToNumber(py);\n\n    if ($isNaN(nx) || $isNaN(ny)) {\n      return undefined;\n    }\n\n    if ($isFinite(nx) && $isFinite(ny) && nx === ny) {\n      return false;\n    }\n\n    if (nx === 0 && ny === 0) {\n      return false;\n    }\n\n    if (nx === Infinity) {\n      return false;\n    }\n\n    if (ny === Infinity) {\n      return true;\n    }\n\n    if (ny === -Infinity) {\n      return false;\n    }\n\n    if (nx === -Infinity) {\n      return true;\n    }\n\n    return nx < ny; // by now, these are both nonzero, finite, and not equal\n  }\n\n  if (isPrefixOf(py, px)) {\n    return false;\n  }\n\n  if (isPrefixOf(px, py)) {\n    return true;\n  }\n\n  return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f\n};","map":{"version":3,"sources":["/home/atude/projects/kanbie/node_modules/es-abstract/2015/AbstractRelationalComparison.js"],"names":["GetIntrinsic","require","$Number","$TypeError","$isNaN","$isFinite","isPrefixOf","ToNumber","ToPrimitive","Type","module","exports","AbstractRelationalComparison","x","y","LeftFirst","px","py","bothStrings","nx","ny","undefined","Infinity"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA1B;;AAEA,IAAIC,OAAO,GAAGF,YAAY,CAAC,UAAD,CAA1B;AACA,IAAIG,UAAU,GAAGH,YAAY,CAAC,aAAD,CAA7B;;AAEA,IAAII,MAAM,GAAGH,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIK,UAAU,GAAGL,OAAO,CAAC,uBAAD,CAAxB;;AAEA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIO,WAAW,GAAGP,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIQ,IAAI,GAAGR,OAAO,CAAC,QAAD,CAAlB,C,CAEA;AAEA;;;AACAS,MAAM,CAACC,OAAP,GAAiB,SAASC,4BAAT,CAAsCC,CAAtC,EAAyCC,CAAzC,EAA4CC,SAA5C,EAAuD;AACvE,MAAIN,IAAI,CAACM,SAAD,CAAJ,KAAoB,SAAxB,EAAmC;AAClC,UAAM,IAAIZ,UAAJ,CAAe,wDAAf,CAAN;AACA;;AACD,MAAIa,EAAJ;AACA,MAAIC,EAAJ;;AACA,MAAIF,SAAJ,EAAe;AACdC,IAAAA,EAAE,GAAGR,WAAW,CAACK,CAAD,EAAIX,OAAJ,CAAhB;AACAe,IAAAA,EAAE,GAAGT,WAAW,CAACM,CAAD,EAAIZ,OAAJ,CAAhB;AACA,GAHD,MAGO;AACNe,IAAAA,EAAE,GAAGT,WAAW,CAACM,CAAD,EAAIZ,OAAJ,CAAhB;AACAc,IAAAA,EAAE,GAAGR,WAAW,CAACK,CAAD,EAAIX,OAAJ,CAAhB;AACA;;AACD,MAAIgB,WAAW,GAAGT,IAAI,CAACO,EAAD,CAAJ,KAAa,QAAb,IAAyBP,IAAI,CAACQ,EAAD,CAAJ,KAAa,QAAxD;;AACA,MAAI,CAACC,WAAL,EAAkB;AACjB,QAAIC,EAAE,GAAGZ,QAAQ,CAACS,EAAD,CAAjB;AACA,QAAII,EAAE,GAAGb,QAAQ,CAACU,EAAD,CAAjB;;AACA,QAAIb,MAAM,CAACe,EAAD,CAAN,IAAcf,MAAM,CAACgB,EAAD,CAAxB,EAA8B;AAC7B,aAAOC,SAAP;AACA;;AACD,QAAIhB,SAAS,CAACc,EAAD,CAAT,IAAiBd,SAAS,CAACe,EAAD,CAA1B,IAAkCD,EAAE,KAAKC,EAA7C,EAAiD;AAChD,aAAO,KAAP;AACA;;AACD,QAAID,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACzB,aAAO,KAAP;AACA;;AACD,QAAID,EAAE,KAAKG,QAAX,EAAqB;AACpB,aAAO,KAAP;AACA;;AACD,QAAIF,EAAE,KAAKE,QAAX,EAAqB;AACpB,aAAO,IAAP;AACA;;AACD,QAAIF,EAAE,KAAK,CAACE,QAAZ,EAAsB;AACrB,aAAO,KAAP;AACA;;AACD,QAAIH,EAAE,KAAK,CAACG,QAAZ,EAAsB;AACrB,aAAO,IAAP;AACA;;AACD,WAAOH,EAAE,GAAGC,EAAZ,CAxBiB,CAwBD;AAChB;;AACD,MAAId,UAAU,CAACW,EAAD,EAAKD,EAAL,CAAd,EAAwB;AACvB,WAAO,KAAP;AACA;;AACD,MAAIV,UAAU,CAACU,EAAD,EAAKC,EAAL,CAAd,EAAwB;AACvB,WAAO,IAAP;AACA;;AACD,SAAOD,EAAE,GAAGC,EAAZ,CA9CuE,CA8CvD;AAChB,CA/CD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $isNaN = require('../helpers/isNaN');\nvar $isFinite = require('../helpers/isFinite');\nvar isPrefixOf = require('../helpers/isPrefixOf');\n\nvar ToNumber = require('./ToNumber');\nvar ToPrimitive = require('./ToPrimitive');\nvar Type = require('./Type');\n\n// https://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5\n\n// eslint-disable-next-line max-statements\nmodule.exports = function AbstractRelationalComparison(x, y, LeftFirst) {\n\tif (Type(LeftFirst) !== 'Boolean') {\n\t\tthrow new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n\t}\n\tvar px;\n\tvar py;\n\tif (LeftFirst) {\n\t\tpx = ToPrimitive(x, $Number);\n\t\tpy = ToPrimitive(y, $Number);\n\t} else {\n\t\tpy = ToPrimitive(y, $Number);\n\t\tpx = ToPrimitive(x, $Number);\n\t}\n\tvar bothStrings = Type(px) === 'String' && Type(py) === 'String';\n\tif (!bothStrings) {\n\t\tvar nx = ToNumber(px);\n\t\tvar ny = ToNumber(py);\n\t\tif ($isNaN(nx) || $isNaN(ny)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif ($isFinite(nx) && $isFinite(ny) && nx === ny) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === 0 && ny === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === Infinity) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ny === Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\tif (ny === -Infinity) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === -Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\treturn nx < ny; // by now, these are both nonzero, finite, and not equal\n\t}\n\tif (isPrefixOf(py, px)) {\n\t\treturn false;\n\t}\n\tif (isPrefixOf(px, py)) {\n\t\treturn true;\n\t}\n\treturn px < py; // both strings, neither a prefix of the other. shortcut for steps c-f\n};\n"]},"metadata":{},"sourceType":"script"}