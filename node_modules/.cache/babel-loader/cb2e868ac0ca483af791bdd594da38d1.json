{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $hasInstance = GetIntrinsic('Symbol.hasInstance', true);\n\nvar Call = require('./Call');\n\nvar GetMethod = require('./GetMethod');\n\nvar IsCallable = require('./IsCallable');\n\nvar OrdinaryHasInstance = require('./OrdinaryHasInstance');\n\nvar ToBoolean = require('./ToBoolean');\n\nvar Type = require('./Type'); // https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator\n\n\nmodule.exports = function InstanceofOperator(O, C) {\n  if (Type(O) !== 'Object') {\n    throw new $TypeError('Assertion failed: Type(O) is not Object');\n  }\n\n  var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;\n\n  if (typeof instOfHandler !== 'undefined') {\n    return ToBoolean(Call(instOfHandler, C, [O]));\n  }\n\n  if (!IsCallable(C)) {\n    throw new $TypeError('`C` is not Callable');\n  }\n\n  return OrdinaryHasInstance(C, O);\n};","map":{"version":3,"sources":["/home/atude/projects/kanbie/node_modules/es-abstract/2015/InstanceofOperator.js"],"names":["GetIntrinsic","require","$TypeError","$hasInstance","Call","GetMethod","IsCallable","OrdinaryHasInstance","ToBoolean","Type","module","exports","InstanceofOperator","O","C","instOfHandler"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA1B;;AAEA,IAAIC,UAAU,GAAGF,YAAY,CAAC,aAAD,CAA7B;AAEA,IAAIG,YAAY,GAAGH,YAAY,CAAC,oBAAD,EAAuB,IAAvB,CAA/B;;AAEA,IAAII,IAAI,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIK,UAAU,GAAGL,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIM,mBAAmB,GAAGN,OAAO,CAAC,uBAAD,CAAjC;;AACA,IAAIO,SAAS,GAAGP,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIQ,IAAI,GAAGR,OAAO,CAAC,QAAD,CAAlB,C,CAEA;;;AAEAS,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,CAA5B,EAA+BC,CAA/B,EAAkC;AAClD,MAAIL,IAAI,CAACI,CAAD,CAAJ,KAAY,QAAhB,EAA0B;AACzB,UAAM,IAAIX,UAAJ,CAAe,yCAAf,CAAN;AACA;;AACD,MAAIa,aAAa,GAAGZ,YAAY,GAAGE,SAAS,CAACS,CAAD,EAAIX,YAAJ,CAAZ,GAAgC,KAAK,CAArE;;AACA,MAAI,OAAOY,aAAP,KAAyB,WAA7B,EAA0C;AACzC,WAAOP,SAAS,CAACJ,IAAI,CAACW,aAAD,EAAgBD,CAAhB,EAAmB,CAACD,CAAD,CAAnB,CAAL,CAAhB;AACA;;AACD,MAAI,CAACP,UAAU,CAACQ,CAAD,CAAf,EAAoB;AACnB,UAAM,IAAIZ,UAAJ,CAAe,qBAAf,CAAN;AACA;;AACD,SAAOK,mBAAmB,CAACO,CAAD,EAAID,CAAJ,CAA1B;AACA,CAZD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $hasInstance = GetIntrinsic('Symbol.hasInstance', true);\n\nvar Call = require('./Call');\nvar GetMethod = require('./GetMethod');\nvar IsCallable = require('./IsCallable');\nvar OrdinaryHasInstance = require('./OrdinaryHasInstance');\nvar ToBoolean = require('./ToBoolean');\nvar Type = require('./Type');\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator\n\nmodule.exports = function InstanceofOperator(O, C) {\n\tif (Type(O) !== 'Object') {\n\t\tthrow new $TypeError('Assertion failed: Type(O) is not Object');\n\t}\n\tvar instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;\n\tif (typeof instOfHandler !== 'undefined') {\n\t\treturn ToBoolean(Call(instOfHandler, C, [O]));\n\t}\n\tif (!IsCallable(C)) {\n\t\tthrow new $TypeError('`C` is not Callable');\n\t}\n\treturn OrdinaryHasInstance(C, O);\n};\n"]},"metadata":{},"sourceType":"script"}